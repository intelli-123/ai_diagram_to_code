const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
const dotenv = require('dotenv');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { editTerraformCode } = require('../services/geminiEditorAgent');
const { exec } = require('child_process');
const { v4: uuidv4 } = require('uuid');

dotenv.config();

let lastGeneratedCode = '';
let lastTfFilePath = '';

const app = express();
app.use(cors());
app.use(express.static('public'));

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Multer setup for image upload
const storage = multer.diskStorage({
  destination: './uploads/',
  filename: (req, file, cb) => cb(null, Date.now() + path.extname(file.originalname)),
});
const upload = multer({ storage });

// Gemini: Parse architecture diagram
async function processImageWithGemini(imagePath) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const imageBytes = fs.readFileSync(imagePath);
  const mimeType = 'image/png';

  const prompt = `
You are a cloud architecture parser. Your task is to extract structured cloud components and their connectivity **only** from valid IT architecture diagrams.

If the image is not a cloud or IT architecture diagram (e.g., a photo, unrelated chart, or random drawing), respond with:
{
  "error": "Invalid diagram. Only IT/cloud architecture diagrams are supported."
}

Otherwise, return a structured JSON object with two keys:
1. "components": a list of cloud components with type, name, and properties.
2. "connections": a list of directional links showing how components are connected.

Only return valid JSON. Do not include explanations or markdown.
`;

  const result = await model.generateContent([
    { text: prompt },
    {
      inlineData: {
        mimeType,
        data: imageBytes.toString('base64'),
      },
    },
  ]);

  const response = await result.response;
  return response.text();
}

// // Gemini: Generate Terraform code from JSON
// async function generateTerraformFromJson(jsonString) {
//   const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

//   const prompt = `
// Convert the following cloud architecture JSON into complete Terraform code using AWS provider. Include all necessary resources, dependencies, and configurations.

// Only return valid Terraform code. Do not include explanations or markdown.

// JSON:
// ${jsonString}
// `;

//   const result = await model.generateContent(prompt);
//   const response = await result.response;
//   return response.text();
// }

// Gemini: Generate Terraform code from JSON

async function generateTerraformFromJson(jsonString) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const prompt = `
Generate complete, raw Terraform code for the AWS provider based on the following JSON representation of a cloud architecture. The code must not contain any markdown formatting (e.g., no backticks) or explanations.

Ensure the generated code includes a 'terraform' block with a mandatory 'required_version' and the 'tflint' plugin configuration as specified below:

terraform {
  required_version = ">= 1.0.0"
}

plugin "terraform" {
  enabled = true
  preset  = "recommended"
}

JSON:
${jsonString}
`;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  return response.text();
}


// Generate unique .tf file path
function getUniqueTfFilePath() {
  const uniqueId = uuidv4().slice(0, 8);
  const filename = `generated_${uniqueId}.tf`;

  // Use a path relative to the current working directory
  const tfDir = path.join(__dirname, '..', 'generated');

  // Add recursive: true to safely create parent directories if they don't exist
  if (!fs.existsSync(tfDir)) {
    fs.mkdirSync(tfDir, { recursive: true });
  }

  return path.join(tfDir, filename);
}

// Upload and process diagram
app.post('/upload', upload.single('diagram'), async (req, res) => {
  try {
    console.log('[DEBUG] Received diagram:', req.file.path);

    const rawJson = await processImageWithGemini(req.file.path);
    console.log('[DEBUG] Raw Gemini response:', rawJson);

    const cleanedJson = rawJson.replace(/```json/g, '').replace(/```/g, '').trim();

    let parsedJson;
    try {
      parsedJson = JSON.parse(cleanedJson);
      console.log('[DEBUG] Parsed JSON successfully');
    } catch (err) {
      console.error('[ERROR] Failed to parse JSON:', err);
      return res.status(400).send('Invalid architecture diagram or JSON format.');
    }

    const terraformCode = await generateTerraformFromJson(JSON.stringify(parsedJson, null, 2));
    console.log('[DEBUG] Terraform code generated by Gemini');

    const tfFilePath = getUniqueTfFilePath();
    fs.writeFileSync(tfFilePath, terraformCode);
    console.log('[DEBUG] Terraform code saved to:', tfFilePath);

    lastGeneratedCode = terraformCode;
    lastTfFilePath = tfFilePath;

    res.type('text/plain').send(terraformCode);
  } catch (err) {
    console.error('[ERROR] Failed to process image or generate Terraform code:', err);
    res.status(500).send('Error generating Terraform code');
  }
});

// Edit Terraform code
app.post('/edit', express.json(), async (req, res) => {
  const { instruction } = req.body;
  try {
    const updatedCode = await editTerraformCode(lastGeneratedCode, instruction);
    lastGeneratedCode = updatedCode;

    if (lastTfFilePath) {
      fs.writeFileSync(lastTfFilePath, updatedCode);
      console.log('[DEBUG] Updated Terraform code saved to:', lastTfFilePath);
    }

    res.type('text/plain').send(updatedCode);
  } catch (err) {
    console.error('[ERROR] Editing failed:', err);
    res.status(500).send('Failed to edit code');
  }
});

// Linting
app.get('/lint', async (req, res) => {
  if (!lastTfFilePath) {
    return res.status(400).send('No Terraform file available for linting.');
  }
  
  // Extract the directory and filename from the last generated file path
  const tfDir = path.dirname(lastTfFilePath);
  const tfFilename = path.basename(lastTfFilePath);

  exec(`tflint --filter=${tfFilename} --chdir ${tfDir}`, (error, stdout, stderr) => {
    if (error) {
      console.error('[ERROR] TFLint failed:', stderr);
      return res.status(500).send(`Linting failed: ${stderr}`);
    }
    res.type('text/plain').send(stdout);
  });
});

// Cost estimation
app.get('/estimate-cost', async (req, res) => {
  if (!lastTfFilePath) return res.status(400).send('No Terraform file available for cost estimation.');

  exec(`oiq --file ${lastTfFilePath} --output json`, (error, stdout, stderr) => {
    if (error) {
      console.error('[ERROR] OpenInfraQuote failed:', stderr);
      return res.status(500).send('Cost estimation failed');
    }

    try {
      const costData = JSON.parse(stdout);
      const totalMonthlyCost = costData.total_monthly_cost || 0;
      res.json({ cost: totalMonthlyCost });
    } catch (err) {
      console.error('[ERROR] Failed to parse cost JSON:', err);
      res.status(500).send('Error parsing cost data');
    }
  });
});

const PORT = process.env.PORT || 3005;
const HOST = process.env.HOST || '0.0.0.0';

app.listen(PORT, HOST, () => {
  console.log(`ðŸš€ Server running at http://${HOST}:${PORT}`);
});


// const express = require('express');
// const multer = require('multer');
// const path = require('path');
// const fs = require('fs');
// const cors = require('cors');
// const dotenv = require('dotenv');
// const { GoogleGenerativeAI } = require('@google/generative-ai');
// const { editTerraformCode } = require('../services/geminiEditorAgent');
// const { exec } = require('child_process');

// dotenv.config();

// let lastGeneratedCode = '';

// const app = express();
// app.use(cors());
// app.use(express.static('public'));

// const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// const storage = multer.diskStorage({
//   destination: './uploads/',
//   filename: (req, file, cb) => cb(null, Date.now() + path.extname(file.originalname)),
// });
// const upload = multer({ storage });

// async function processImageWithGemini(imagePath) {
//   const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

//   const imageBytes = fs.readFileSync(imagePath);
//   const mimeType = 'image/png'; // You can enhance this to detect dynamically

//   const prompt = `
// You are a cloud architecture parser. Your task is to extract structured cloud components and their connectivity **only** from valid IT architecture diagrams.

// If the image is not a cloud or IT architecture diagram (e.g., a photo, unrelated chart, or random drawing), respond with:
// {
//   "error": "Invalid diagram. Only IT/cloud architecture diagrams are supported."
// }

// Otherwise, return a structured JSON object with two keys:
// 1. "components": a list of cloud components with type, name, and properties.
// 2. "connections": a list of directional links showing how components are connected.

// Only return valid JSON. Do not include explanations or markdown.
// `;

//   const result = await model.generateContent([
//     { text: prompt },
//     {
//       inlineData: {
//         mimeType,
//         data: imageBytes.toString('base64'),
//       },
//     },
//   ]);

//   const response = await result.response;
//   return response.text();
  
// }

// async function generateTerraformFromJson(jsonString) {
//   const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

//   const prompt = `
// Convert the following cloud architecture JSON into complete Terraform code using AWS provider. Include all necessary resources, dependencies, and configurations.

// Only return valid Terraform code. Do not include explanations or markdown.

// JSON:
// ${jsonString}
// `;

//   const result = await model.generateContent(prompt);
//   const response = await result.response;
//   return response.text();
// }

// app.post('/upload', upload.single('diagram'), async (req, res) => {
//   try {
//     console.log('[DEBUG] Received diagram:', req.file.path);

//     const rawJson = await processImageWithGemini(req.file.path);
//     console.log('[DEBUG] Raw Gemini response:', rawJson);

//     const cleanedJson = rawJson
//       .replace(/```json/g, '')
//       .replace(/```/g, '')
//       .trim();

//     let parsedJson;
//     try {
//       parsedJson = JSON.parse(cleanedJson);
//       console.log('[DEBUG] Parsed JSON successfully');
//     } catch (err) {
//       console.error('[ERROR] Failed to parse JSON:', err);
//       return res.status(400).send('Invalid architecture diagram or JSON format.');
//     }

//     const terraformCode = await generateTerraformFromJson(JSON.stringify(parsedJson, null, 2));
//     console.log('[DEBUG] Terraform code generated by Gemini');

//     const tfDir = path.join(__dirname, '../public/generated');
//     if (!fs.existsSync(tfDir)) fs.mkdirSync(tfDir, { recursive: true });

//     const tfFilePath = path.join(tfDir, 'generated_from_diagram.tf');
//     fs.writeFileSync(tfFilePath, terraformCode);
//     console.log('[DEBUG] Terraform code saved to:', tfFilePath);

//     lastGeneratedCode = terraformCode;
//     res.type('text/plain').send(terraformCode);

//   } catch (err) {
//     console.error('[ERROR] Failed to process image or generate Terraform code:', err);
//     res.status(500).send('Error generating Terraform code');
//   }

// });

// app.post('/edit', express.json(), async (req, res) => {
//   const { instruction } = req.body;
//   try {
//     const updatedCode = await editTerraformCode(lastGeneratedCode, instruction);
//     lastGeneratedCode = updatedCode;
//     res.type('text/plain').send(updatedCode);
//   } catch (err) {
//     console.error('[ERROR] Editing failed:', err);
//     res.status(500).send('Failed to edit code');
//   }
// });

// // Linting

// app.get('/lint', async (req, res) => {
//   const tfDir = path.join(__dirname, '../public/generated');

//   exec(`tflint --chdir ${tfDir}`, (error, stdout, stderr) => {
//     if (error) {
//       console.error('[ERROR] TFLint failed:', stderr);
//       return res.status(500).send('Linting failed');
//     }
//     res.type('text/plain').send(stdout);
//   });
// });

// // cost estimate

// app.get('/estimate-cost', async (req, res) => {
//   const tfFilePath = path.join(__dirname, '../public/generated/generated_from_diagram.tf');

//   exec(`oiq --file ${tfFilePath} --output json`, (error, stdout, stderr) => {
//     if (error) {
//       console.error('[ERROR] OpenInfraQuote failed:', stderr);
//       return res.status(500).send('Cost estimation failed');
//     }

//     try {
//       const costData = JSON.parse(stdout);
//       const totalMonthlyCost = costData.total_monthly_cost || 0;
//       res.json({ cost: totalMonthlyCost });
//     } catch (err) {
//       console.error('[ERROR] Failed to parse cost JSON:', err);
//       res.status(500).send('Error parsing cost data');
//     }
//   });
// });

// const PORT = process.env.PORT || 3005;
// const HOST = process.env.HOST || '0.0.0.0'; // '0.0.0.0' means all available IP addresses

// app.listen(PORT, HOST, () => {
//     console.log(`ðŸš€ Server running at http://${HOST}:${PORT}`);
// });





// const express = require('express');
// const multer = require('multer');
// const path = require('path');
// const fs = require('fs');
// const cors = require('cors');
// const dotenv = require('dotenv');
// const { processImageWithGemini } = require('../services/geminiProcessor');

// dotenv.config();

// const app = express();
// app.use(cors());
// app.use(express.static('public'));

// const storage = multer.diskStorage({
//   destination: './uploads/',
//   filename: (req, file, cb) => cb(null, Date.now() + path.extname(file.originalname)),
// });
// const upload = multer({ storage });

// // Utility to sanitize Terraform resource names
// const sanitizeName = name => name.toLowerCase().replace(/\s+/g, '_').replace(/-/g, '_');

// // Terraform templates for supported components
// const terraformTemplates = {
//   "VPC": (comp) => `
// resource "aws_vpc" "${sanitizeName(comp.name)}" {
//   cidr_block = "${comp.properties.cidr_block}"
// }
// `,
//   "Internet Gateway": (comp) => `
// resource "aws_internet_gateway" "${sanitizeName(comp.name)}" {
//   vpc_id = aws_vpc.${sanitizeName(comp.properties.vpc || 'vpc')}.id
// }
// `,
//   "Subnet": (comp) => `
// resource "aws_subnet" "${sanitizeName(comp.name)}" {
//   vpc_id = aws_vpc.${sanitizeName(comp.properties.vpc || 'vpc')}.id
//   cidr_block = "${comp.properties.cidr_block}"
// }
// `,
//   "EC2 Instances": (comp) => {
//     const subnetName = sanitizeName(comp.properties.located_in_subnet || 'subnet');
//     const count = comp.properties.count || 1;
//     let instances = '';
//     for (let i = 0; i < count; i++) {
//       instances += `
// resource "aws_instance" "${sanitizeName(comp.name)}_${i + 1}" {
//   ami           = "ami-12345678"
//   instance_type = "t2.micro"
//   subnet_id     = aws_subnet.${subnetName}.id
// }
// `;
//     }
//     return instances;
//   }
// };

// app.post('/upload', upload.single('diagram'), async (req, res) => {
//   try {
//     console.log('[DEBUG] Received diagram:', req.file.path);

//     const result = await processImageWithGemini(req.file.path);
//     console.log('[DEBUG] Raw Gemini response:', result);

//     const cleaned = result
//       .replace(/```terraform/g, '')
//       .replace(/```json/g, '')
//       .replace(/```/g, '')
//       .trim();

//     let parsedJson = null;
//     let terraformCode = '';

//     try {
//       parsedJson = JSON.parse(cleaned);
//       console.log('[DEBUG] Parsed JSON successfully');
//     } catch {
//       terraformCode = cleaned;
//       console.log('[DEBUG] Response is raw Terraform code');
//     }

//     if (parsedJson) {
//       console.log('[DEBUG] Generating Terraform code from parsed JSON');
//       parsedJson.components.forEach(comp => {
//         const generator = terraformTemplates[comp.type];
//         if (generator) {
//           console.log(`[DEBUG] Generating for ${comp.type}: ${comp.name}`);
//           terraformCode += generator(comp) + '\n';
//         } else {
//           console.log(`[DEBUG] No template for component type: ${comp.type}`);
//         }
//       });
//     }

//     const tfDir = path.join(__dirname, '../public/generated');
//     if (!fs.existsSync(tfDir)) fs.mkdirSync(tfDir, { recursive: true });

//     const tfFilePath = path.join(tfDir, 'generated_from_diagram.tf');
//     fs.writeFileSync(tfFilePath, terraformCode);
//     console.log('[DEBUG] Terraform code saved to:', tfFilePath);

//     res.type('text/plain').send(terraformCode);

//   } catch (err) {
//     console.error('[ERROR] Failed to process image or generate Terraform code:', err);
//     res.status(500).send('Error generating Terraform code');
//   }
// });

// const PORT = process.env.PORT || 3000;
// app.listen(PORT, () => console.log(`ðŸš€ Server running at http://localhost:${PORT}`));
