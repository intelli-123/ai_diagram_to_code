const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
const dotenv = require('dotenv');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { editTerraformCode } = require('../services/geminiEditorAgent');
const { exec } = require('child_process');
const { v4: uuidv4 } = require('uuid');

dotenv.config();

let lastGeneratedCode = '';
let lastTfFilePath = '';

const app = express();
app.use(cors());
app.use(express.static('public'));

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Multer setup for image upload
const storage = multer.diskStorage({
  destination: './uploads/',
  filename: (req, file, cb) => cb(null, Date.now() + path.extname(file.originalname)),
});
const upload = multer({ storage });

// ðŸ§  Gemini: Parse architecture diagram
async function processImageWithGemini(imagePath) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const imageBytes = fs.readFileSync(imagePath);
  const mimeType = 'image/png';

  const prompt = `
You are a cloud architecture parser. Your task is to extract structured cloud components and their connectivity **only** from valid IT architecture diagrams.

If the image is not a cloud or IT architecture diagram (e.g., a photo, unrelated chart, or random drawing), respond with:
{
  "error": "Invalid diagram. Only IT/cloud architecture diagrams are supported."
}

Otherwise, return a structured JSON object with two keys:
1. "components": a list of cloud components with type, name, and properties.
2. "connections": a list of directional links showing how components are connected.

Only return valid JSON. Do not include explanations or markdown.
`;

  const result = await model.generateContent([
    { text: prompt },
    {
      inlineData: {
        mimeType,
        data: imageBytes.toString('base64'),
      },
    },
  ]);

  const response = await result.response;
  return response.text();
}

// ðŸ§© Gemini: Generate valid Terraform code for AWS
async function generateTerraformFromJson(jsonString) {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const prompt = `
Generate complete, valid Terraform code for AWS based on this cloud architecture JSON.
The output must be valid HCL with no markdown formatting, no explanations, and no multi-line quoted strings.

Ensure the Terraform block looks like this:

terraform {
  required_version = ">= 1.0.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0.0"
    }
  }
}

All string values must be on a single line. Do not split quoted strings across multiple lines. If a multi-line string is required, use heredoc syntax.

JSON:
${jsonString}
`;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  return response.text();
}

// Generate unique .tf file path
function getUniqueTfFilePath() {
  const uniqueId = uuidv4().slice(0, 6);
  const filename = `generated_${uniqueId}.tf`;

  const tfDir = path.join(__dirname, '..', `generated_${uniqueId}`);
  if (!fs.existsSync(tfDir)) {
    fs.mkdirSync(tfDir, { recursive: true });
  }

  return path.join(tfDir, filename);
}

// ðŸ“¸ Upload and process diagram
app.post('/upload', upload.single('diagram'), async (req, res) => {
  try {
    console.log('[DEBUG] Received diagram:', req.file.path);

    const rawJson = await processImageWithGemini(req.file.path);
    console.log('[DEBUG] Raw Gemini response:', rawJson);

    const cleanedJson = rawJson.replace(/```json/g, '').replace(/```/g, '').trim();

    let parsedJson;
    try {
      parsedJson = JSON.parse(cleanedJson);
      console.log('[DEBUG] Parsed JSON successfully');
    } catch (err) {
      console.error('[ERROR] Failed to parse JSON:', err);
      return res.status(400).send('Invalid architecture diagram or JSON format.');
    }

    let terraformCode = await generateTerraformFromJson(JSON.stringify(parsedJson, null, 2));
    console.log('[DEBUG] Terraform code generated by Gemini');

    // âœ… Clean invalid Terraform syntax before saving (skip ZIP + inline_code)
    let cleanedTerraform = terraformCode
      // Remove invalid archive or zip-related lines
      .replace(/data\s+"archive_file"[^}]+}/g, '')
      .replace(/zip_file\s*=\s*[^\n]*/g, '')
      .replace(/source_file\s*=\s*[^\n]*/g, '')
      .replace(/source_dir\s*=\s*[^\n]*/g, '')
      .replace(/source_content.*(\n|$)/g, '')
      .replace(/output_path\s*=\s*".*"/g, '# skipped output_path')
      .replace(/source_code_hash\s*=\s*filebase64sha256\(.*\)/g, '# skipped hash')
      // Replace filename references with dummy
      .replace(/filename\s*=\s*".*"/g, 'filename = "lambda/dummy_lambda.js"')
      // âœ… Remove inline_code blocks and replace with valid placeholder
      .replace(/inline_code\s*{[^}]*}/g, 'source_code = "exports.handler = async () => { return \\"OK\\"; }"')
      // Fix unclosed interpolation expressions
      .replace(/\$\{path\.module\s*$/gm, '${path.module}')
      .replace(/\$\{([^}]+)\n/g, (_, expr) => `\${${expr.trim()}}`)
      // Clean up empty lines
      .replace(/^\s*$/gm, '');

    const tfFilePath = getUniqueTfFilePath();
    fs.writeFileSync(tfFilePath, cleanedTerraform);
    console.log('[DEBUG] Cleaned & saved Terraform code to:', tfFilePath);

    // âœ… Create .tflint.hcl for linting
    const tflintConfig = `
plugin "terraform" {
  enabled = true
  preset  = "recommended"
}
`;
    const tfDir = path.dirname(tfFilePath);
    fs.writeFileSync(path.join(tfDir, '.tflint.hcl'), tflintConfig);
    console.log('[DEBUG] .tflint.hcl created');

    lastGeneratedCode = cleanedTerraform;
    lastTfFilePath = tfFilePath;

    res.type('text/plain').send(cleanedTerraform);
  } catch (err) {
    console.error('[ERROR] Failed to process image or generate Terraform code:', err);
    res.status(500).send('Error generating Terraform code');
  }
});

// ðŸ§  Edit Terraform code dynamically
app.post('/edit', express.json(), async (req, res) => {
  const { instruction } = req.body;
  try {
    const updatedCode = await editTerraformCode(lastGeneratedCode, instruction);
    lastGeneratedCode = updatedCode;

    if (lastTfFilePath) {
      fs.writeFileSync(lastTfFilePath, updatedCode);
      console.log('[DEBUG] Updated Terraform code saved to:', lastTfFilePath);
    }

    res.type('text/plain').send(updatedCode);
  } catch (err) {
    console.error('[ERROR] Editing failed:', err);
    res.status(500).send('Failed to edit code');
  }
});

// ðŸ§¹ Linting Endpoint
app.get('/lint', async (req, res) => {
  if (!lastTfFilePath) return res.status(400).send('No Terraform file for linting.');

  const tfDir = path.dirname(lastTfFilePath);
  const tfFilename = path.basename(lastTfFilePath);

  const cmd = `
    cd ${tfDir} &&
    terraform init -input=false -no-color &&
    terraform validate -no-color &&
    tflint --filter=${tfFilename}
  `;

  exec(cmd, (error, stdout, stderr) => {
    let output = '';

    if (stdout) {
      output += `[STDOUT] ${stdout}\n`;
    }
    if (stderr) {
      output += `[STDERR] ${stderr}\n`;
    }

    if (error) {
      console.error('[ERROR] Linting failed:', output);
      return res.status(500).send(`Linting failed: ${output}`);
    }

    if (!output) {
      output = 'No linting issues found.';
    }

    res.type('text/plain').send(output);
  });
});

// ðŸ’° Cost Estimation (OpenInfraQuote)
app.get('/estimate-cost', async (req, res) => {
  if (!lastTfFilePath) return res.status(400).send('No Terraform file for cost estimation.');

  const tfDir = path.dirname(lastTfFilePath);

  const cmd = `
    cd ${tfDir} &&
    curl -s https://oiq.terrateam.io/prices.csv.gz | gunzip > prices.csv
    terraform init -input=false -no-color &&
    terraform validate -no-color &&
    terraform plan -out=tf.plan -no-color &&
    terraform show -json tf.plan > tfplan.json &&
    oiq match --pricesheet prices.csv tfplan.json | oiq price
  `;

  console.log('[INFO] Running cost estimation in:', tfDir);

  exec(cmd, { shell: '/bin/bash', maxBuffer: 1024 * 1024 * 10 }, (error, stdout, stderr) => {
    if (error) {
      console.error('[ERROR] OIQ estimation failed:', stderr || error);
      return res.status(500).send('Error running OpenInfraQuote.');
    }

    if (stderr) {
        console.warn('OIQ STDERR:', stderr);
    }

    // Send raw stdout as preformatted text
    res.type('text/plain').send(stdout);
  });
});

// Start Server
const PORT = process.env.PORT || 3005;
const HOST = process.env.HOST || '0.0.0.0';
app.listen(PORT, HOST, () => {
  console.log(`ðŸš€ Server running at http://${HOST}:${PORT}`);
});
